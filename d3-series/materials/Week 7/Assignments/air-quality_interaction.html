<html>
  <head>
    <style>
      body {
        margin: 0;
      }
      main {
        background-color: #1c2431;
        align-items: center;
        display: flex;
        height: 100%;
        justify-content: center;
        width: 100%;
      }
      .chart-container-outer {
        background-color: #283142;
        border-radius: 1rem;
        margin: auto;
      }
      .chart-container-outer text {
        fill: white;
        font-family: arial;
        font-weight: bold;
      }
      .chart-container-outer .domain,
      .chart-container-outer .tick line {
        stroke: white;
      }
      .x-axis-label,
      .y-axis-label,
      .chart-title {
        text-anchor: middle;
      }
      .chart-title {
        font-size: 24px;
      }
      .content {
        position: relative;
      }
      .sort-radio-buttons {
        display: flex;
        flex-direction: column;
        height: fit-content;
        position: absolute;
        top: 50px;
        left: 125px;
        border-radius: 1rem;
        padding: 1rem;
        background-color: #1c2431;
        font-family: arial;
      }
      .sort-radio-button {
        margin-right: 0.75rem;
      }
      .sort-radio-button-label {
        color: white;
        display: flex;
        margin: 0.25rem;
      }
      .transition-delay-input-label {
        color: white;
        font-family: arial;
        margin-left: 0.5rem;
      }
      #transition-delay-input {
        margin-left: 1rem;
      }
    </style>
  </head>
  <body>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
      const buildChart = (containerSelector, data) => {
        data.forEach(
          (d) => (d.Emissions = Number(d.Emissions.replace(/,/g, "")))
        );

        const sortDataByRegion = (data) => {
          let sortedData = [];
          const regions = {};
          const dataDeepCopy = JSON.parse(JSON.stringify(data));

          dataDeepCopy.forEach((d) => {
            if (!regions[d.Region]) {
              regions[d.Region] = [d];
            } else {
              regions[d.Region].push(d);
            }
          });

          Object.values(regions).forEach((region) => {
            sortedData = sortedData.concat(
              region.sort((a, b) => a.Emissions - b.Emissions)
            );
          });

          return sortedData;
        };

        data = sortDataByRegion(data);

        const height = 800;
        const barSpacing = 5;
        const barWidth = 20;
        const width = data.length * (barSpacing + barWidth);

        const margin = {
          top: 50,
          right: 50,
          bottom: 50,
          left: 100,
        };

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        let transitionDuration = 1500;
        let transitionDelay = 0;

        const containerOuter = d3
          .select(containerSelector)
          .append("svg")
          .attr("class", "chart-container-outer")
          .attr("height", height)
          .attr("width", width);

        const containerInner = containerOuter
          .append("g")
          .attr("transform", `translate(${margin.left}, ${margin.right})`);

        const x = d3
          .scaleBand()
          .domain(data.map((d) => d.State))
          .range([0, innerWidth]);

        const y = d3
          .scaleLinear()
          .domain([0, d3.max(data, (d) => d.Emissions)])
          .range([innerHeight, 0]);

        const xAxis = d3.axisBottom(x).tickSize(0);

        containerInner
          .append("g")
          .attr("class", "x-axis")
          .attr("transform", `translate(0, ${innerHeight})`)
          .call(xAxis);

        containerInner
          .append("text")
          .attr("class", "x-axis-label")
          .attr("x", innerWidth / 2)
          .attr("y", innerHeight + 35)
          .text("State");

        const yAxis = d3.axisLeft(y).ticks(20);

        containerInner.append("g").attr("class", "y-axis").call(yAxis);

        containerInner
          .append("text")
          .attr("class", "y-axis-label")
          .attr("x", 0)
          .attr("y", innerHeight / 2 - 30)
          .attr("transform", "rotate(-90,-30," + innerHeight / 2 + ")")
          .text("Death Poofs per Zillion");

        containerInner
          .append("text")
          .attr("class", "chart-title")
          .attr("x", innerWidth / 2)
          .attr("y", -20)
          .text("US Emissions by State and Region");

        const fills = {
          South: "purple",
          Northeast: "blue",
          Midwest: "green",
          West: "orange",
        };

        const bars = containerInner
          .selectAll(".bar")
          .data(data)
          .enter()
          .append("rect")
          .attr("class", "bar")
          .attr("x", (d) => x(d.State))
          .attr("y", (d) => y(d.Emissions))
          .attr("width", barWidth)
          .attr("height", (d) => innerHeight - y(d.Emissions))
          .attr("fill", (d) => fills[d.Region]);

        // TODO: Refactor the following event listeners using d3 data joins, see us-station_interaction.html.
        // TODO: Input container is dynamically repositioned to avoid overlapping bars.

        // TODO: Change x axis labels to reflect changes.
        d3.select("#ascending").on("click", () => {
          // NOTE: There's probably a better way to do this...
          const sorted = data.sort((a, b) =>
            d3.ascending(a.Emissions, b.Emissions)
          );
          x.domain(sorted.map((d) => d.State));
          /////////////////////////////////////////////////////

          bars
            .sort((a, b) => d3.ascending(a.Emissions, b.Emissions))
            .transition()
            .duration(transitionDuration)
            .delay((d, i) => i * transitionDelay)
            .attr("x", (d) => x(d.State));
        });

        // TODO: Change x axis labels to reflect changes.
        d3.select("#descending").on("click", () => {
          // NOTE: There's probably a better way to do this...
          const sorted = data.sort((a, b) =>
            d3.descending(a.Emissions, b.Emissions)
          );
          x.domain(sorted.map((d) => d.State));
          /////////////////////////////////////////////////////

          bars
            .sort((a, b) => d3.descending(a.Emissions, b.Emissions))
            .transition()
            .duration(transitionDuration)
            .delay((d, i) => i * transitionDelay)
            .attr("x", (d) => x(d.State));
        });

        // TODO: Change x axis labels to reflect changes.
        d3.select("#state").on("click", () => {
          // NOTE: There's probably a better way to do this...
          const sorted = data.sort((a, b) => d3.ascending(a.State, b.State));
          x.domain(sorted.map((d) => d.State));
          /////////////////////////////////////////////////////

          bars
            .sort((a, b) => d3.descending(a.State, b.State))
            .transition()
            .duration(transitionDuration)
            .delay((d, i) => i * transitionDelay)
            .attr("x", (d) => x(d.State));
        });

        // TODO: Change x axis labels to reflect changes.
        // BUG: Interferes with other sorts.
        // Emissions - > Region -> Emissions
        d3.select("#region").on("click", () => {
          // NOTE: There's probably a better way to do this...
          const sorted = sortDataByRegion(data);
          x.domain(sorted.map((d) => d.State));
          /////////////////////////////////////////////////////

          bars
            .data(sorted)
            .transition()
            .duration(transitionDuration)
            .delay((d, i) => i * transitionDelay)
            .attr("x", (d) => x(d.State));
        });

        d3.select("#transition-delay-input").on("change", (d, i, element) => {
          const value = Number(element[0].value);
          if (typeof value === "number" && value >= 0) {
            transitionDelay = value;
          } else {
            element[0].value = "";
            alert("Enter a valid number");
            d3.event.preventDefault();
          }
        });
      };

      d3.csv("./air_quality.csv")
        .then((data) => buildChart(".content", data))
        .catch((error) => console.error(error));
    </script>
    <main>
      <div class="content">
        <div class="sort-radio-buttons">
          <label class="sort-radio-button-label">
            <input
              class="sort-radio-button"
              id="region"
              name="sort"
              type="radio"
            />
            Sort by Region
          </label>

          <label class="sort-radio-button-label">
            <input
              class="sort-radio-button"
              id="state"
              name="sort"
              type="radio"
            />
            Sort by State
          </label>

          <label class="sort-radio-button-label">
            <input
              class="sort-radio-button"
              id="descending"
              name="sort"
              type="radio"
            />
            Sort by Emissions Descending
          </label>

          <label class="sort-radio-button-label">
            <input
              class="sort-radio-button"
              id="ascending"
              name="sort"
              type="radio"
            />
            Sort by Emissions Ascending
          </label>

          <label class="transition-delay-input-label">
            Transition Delay Input
            <input
              id="transition-delay-input"
              placeholder="Enter delay here"
              type="text"
            />
          </label>
        </div>
      </div>
    </main>
  </body>
</html>
